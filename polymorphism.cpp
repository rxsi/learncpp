#include <iostream>
using namespace std;
/*
多态性
注意：多态只有1）虚函数;2）父类指针指向子类实例时才有！！！！！！！！！！！！！！！！！！！！！
*/

// class A
// {
// public:
//     virtual void vir_fun()
//     {
//         cout << "A::vir_fun()" << endl;
//     }

//     void nor_fun()
//     {
//         cout << "A::nor_fun()" << endl;
//     }
// };

// class B: public A
// {
// public:
//     void vir_fun() override
//     {
//         cout << "B::vir_fun()" << endl;
//     }

//     // void nor_fun()
//     // {
//     //     cout << "B::nor_fun()" << endl;
//     // }
// };

// int main()
// {
//     A *a = new B();
//     a->vir_fun(); // 例1：输出B::vir_fun()，具有多态性，如果子类没有重写这个虚拟函数，会自动调用父类的虚拟函数
//     a->nor_fun(); // 例2：输出A::nor_fun()，不具备多态性，因为直接调用的是父类的方法，因此子类没有重写也没有关系

//     B *b = new B();
//     b->vir_fun(); // 例3：优先调用子类的虚拟函数，如果子类没有重写则会调用父类的虚拟函数
//     b->nor_fun(); // 例4：优先调用子类的函数，如果子类没有重写则会调用父类的函数

// }


class A
{
public:
    virtual void vir_fun()
    {
        cout << "A::vir_fun()" << endl;
    }

    void nor_fun()
    {
        cout << "A::nor_fun()" << endl;
    }

    virtual ~A() = default; // 定义虚析构函数，才能保证在多态调用情况下，能够准确的调用到子类的析构函数
};

class B: public A
{
public:
    void vir_fun(int) // 如果没有对父类的虚拟函数进行重写（同名、同参数、同返回值），那就会形成隐藏
    {
        cout << "B::vir_fun(int)" << endl;
    }


    // virtual void vir_fun()
    // {
    //     cout << "B::vir_fun()" << endl;
    // }

    void nor_fun(int)
    {
        cout << "B::nor_fun()" << endl;
    }
};

class C: public B
{
public:
    // void vir_fun() override // 尽管直接父类B对父类A的虚函数进行了隐藏，但是子类C还是可以重写
    // {
    //     cout << "C::vir_fun()" << endl;
    // }

};

class D: public C
{
public:
    // void vir_fun() override
    // {
    //     cout << "D::vir_fun()" << endl;
    // }
};

int main()
{
    A *a = new B();
    // a->vir_fun(); // 例5：输出A::vir_fun()，具有多态性，尽管子类隐藏了父类的虚函数，但是还是可以调用到父类的函数，前提是父类没有隐藏这个虚函数
    a->nor_fun(); // 例6：输出A::nor_fun()，不具备多态性，因为直接调用的是父类的方法，因此子类没有重写也没有关系,如果父类没有定义的话，那就会报错了

    B *b = new B();
    // b->vir_fun(); // 例7：注意，并不具有多态性，当子类对父类的虚函数进行隐藏时，将会报错。如果子类没有隐藏，则可以成功调用到父类的方法
    // b->nor_fun(); // 例8：同样的，如果子类对父类的方法进行了隐藏，那么调用会失败

    // B *c = new C();
    // // c->vir_fun(); // 例9：B本身隐藏了A的虚函数，尽管C可以重写该虚函数，但是B指针将会无法调用
    // c->nor_fun();

    // C *d = new D();
    // //d->vir_fun(); // 例10：调用成功，顺序调用到C重写的新虚函数，如果C没有重写，那么就会调用失败，因为B已经进行了隐藏
    // d->nor_fun();

    // B b;
    // b->nor_fun();
    // A *e = new C();
    // // e->vir_fun();
}
/*
总结：
多态性需要满足的条件有：
    1）调用的是一个虚函数
    2）是一个父类指向子类实例的指针
    3）父类有该虚函数（也就是父类不能调用子类特有的虚函数）

重写：只出现在虚函数之间，子类对父类同名，同参数，同返回值的虚函数的重写
隐藏：子类定义了与父类同名的普通函数，或者定义了同名但其他部分不相同的虚函数名，都造成隐藏。隐藏的效果是当查询某个函数，查到该子类时，因为隐藏的缘故，查询会到此为止，如果匹配上了参数
那么调用成功，否则调用失败，报错。
重载：智能出现在同一个类中，同名，其他各部分不相同

当一个类中有虚函数时，会生成一张虚函数表，每个虚函数在表中存放着自己的地址，当子类没有重写父类的某个虚函数时，在子类的表中对应的虚函数地址则指向的是父类中定义的那个虚函数
在类内存开始的地方会有一个虚指针，指向本类的虚函数表

1. 当满足多态性条件，调用虚函数时，会通过子类的虚指针，查询子类的虚函数表，从而定位到对应的虚函数，根据子类是否有重写父类的虚函数，该虚函数有可能是子类重写的，也有可能是父类定义的，如例1

2. 当满足多态性条件，但是调用的是非虚函数时，不会出现多态性，调用的是父类的函数，如例2

3. 当是子类指向子类实例的指针，
    1）普通函数，如果没有隐藏，那么会往父类查，查不到则报错，被隐藏了且参数不一致，就会报错。
    2）虚函数，会查询自己的虚函数表，如果没有重写或隐藏，那么会查找到定义在父类的虚函数，查不到则报错， 例3,例4

4. 当子类对父类的函数（不区分是否是虚函数）形成隐藏时，如果是一个父类指向子类实例的指针调用，则结果不变（虚函数会顺序遍历到父类的虚函数，非虚函数这样调用本身调用的就是父类的函数，
因此没有问题），如例5,例6。但是当为子类指针指向子类实例的调用会失败，如例7,例8

5. 当父类B隐藏了父类A的某个虚函数时，尽管子类C重写了父类A的虚函数，但是B的指针无法调用该虚函数，多态性倍破坏，如例9,例10
*/